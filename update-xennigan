#!/usr/bin/env python3

import os
import sys
import pwd
import grp
import stat
import base64
import struct
import shutil
import os.path
import binascii
import argparse
import subprocess

from distutils.util import strtobool

class PleaseExit(Exception):
    def __init__(self, code):
        self.code = code

def ask_confirmation():
    """ Asks user "yes or no" on the console """
    while True:
        try:
            return strtobool(input('[y/n] ').lower())
        except ValueError:
            pass

# From github.com/bwesterb/claviger
def check_ssh_key(b64key, keytype):
    """ Check whether key seems to be a valid base64-encoded string
        with the given keytype. """
    try:
        key = base64.b64decode(b64key)
    except (TypeError, binascii.Error):
        return False
    if len(key) < 5:
        return False
    keytype_len = struct.unpack('>I', key[:4])[0]
    if keytype_len != len(keytype):
        return False
    if not key[4:].startswith(keytype):
        return False
    return True


class Program:
    def main(self, argv):
        self.parse_cmdline(argv)
        self.inspect_environment()
        self.write_configfile()
        self.write_authorized_keys()

    def parse_cmdline(self, argv):
        parser = argparse.ArgumentParser(description='Set up xennigan-shell.')
        parser.add_argument('-x', '--xl-path', type=bytes, metavar='PATH',
                            help="Path to `xl' binary")
        parser.add_argument('-s', '--shell-path', type=bytes, metavar='PATH',
                            help="Path to `xennigan-shell' binary")
        parser.add_argument('-u', '--user', type=str, default='xennigan',
                            help="User to use for xennigan")
        parser.add_argument('-g', '--group', type=str, default='xennigan',
                            help="Group to use for xennigan")
        parser.add_argument('-d', '--domu-cfg-dir', type=str, metavar='DIR',
                            default='/etc/xen',
                            help="Directory for domu configuration files")
        self.args = parser.parse_args()

    def write_authorized_keys(self):
        # First, find domus
        with open(self.ak_path, 'wb') as f:
            f.write(b'# Maintained by update-xennigan.\n')
            for fn in os.listdir(self.args.domu_cfg_dir):
                if not fn.endswith('.cfg'):
                    continue
                domu_name = fn[:-len('.cfg')]
                keys_path = os.path.join(self.args.domu_cfg_dir,
                                    domu_name + '.keys')
                if not os.path.exists(keys_path):
                    print('{0}: no keys file'.format(domu_name))
                    continue

                # Parse keys file
                with open(keys_path, 'rb') as g:
                    key_lines = g.readlines()
                n_keys = 0
                for lineno, raw_key_line in enumerate(key_lines):
                    # Ignore blank lines and comments
                    stripped_line = raw_key_line.strip()
                    if not stripped_line or stripped_line.startswith(b'#'):
                        continue
                    # Check if we have a proper key (and thus, there are no
                    # option shenanigans.
                    bits = stripped_line.split()
                    if len(bits) <= 1:
                        print('{0}: ignoring line {1}'.format(
                                    domu_name, lineno))
                        continue
                    if not check_ssh_key(bits[1], bits[0]):
                        print('{0}: invalid ssh key on line {1}'.format(
                                    domu_name, lineno))
                        continue
                    # Everything seems OK.  Include key
                    n_keys += 1
                    f.write(b'command="')
                    f.write(self.shell_path)
                    f.write(b' ')
                    f.write(domu_name.encode('utf-8'))
                    f.write(b'",')
                    f.write(b'no-port-forwarding,no-X11-forwarding,'
                            b'no-agent-forwarding ')
                    f.write(bits[0] + b' ' + bits[1] + b'\n')
                print("{0}: {1} keys".format(domu_name, n_keys))


    def write_configfile(self):
        with open('/etc/xennigan-shell.conf', 'wb') as f:
            f.write(b'# Autogenerated by update-xennigan.\n')
            f.write(b'xl-path = ')
            f.write(self.xl_path)
            f.write(b'\ndomu-cfg-path = ')
            f.write(self.args.domu_cfg_dir.encode('utf-8'))
            f.write(b'/%1%.cfg\n')

    def inspect_environment(self):
        # Find xl
        self.xl_path = self.args.xl_path
        if not self.xl_path:
            tmp = shutil.which('xl')
            self.xl_path = tmp.encode('utf-8') if tmp else None
        if not self.xl_path:
            self.xl_path = b'/usr/sbin/xl'
        if not os.path.exists(self.xl_path):
            print("Could not find `xl' executable.  Please specify one "
                   "with --xl-path.")
            raise PleaseExit(-1)
        if not self.xl_path.startswith(b'/'):
            print("Path to `xl' should be absolute.")
            raise PleaseExit(-2)

        # Find xennigan-shell
        self.shell_path = self.args.shell_path
        if not self.shell_path:
            tmp = shutil.which('xennigan-shell')
            self.shell_path = tmp.encode('utf-8') if tmp else None
        if not self.shell_path:
            self.shell_path = b'/usr/sbin/xennigan-shell'
        if not os.path.exists(self.shell_path):
            print("Could not find `xennigan-shell' executable.  "
                  "Please specify one with --shell-path.")
            raise PleaseExit(-6)
        if b'"' in self.shell_path:
            print("Shell to xennigan-shell cannot contain double-quote")
            raise PleaseExit(-15)

        # Find xennigan group
        try:
            grp.getgrnam(self.args.group)
        except KeyError:
            print("Group {0} not found.  Create?".format(self.args.group))
            if not ask_confirmation():
                raise PleaseExit(-4)
            subprocess.check_call([
                    'addgroup', self.args.group,
                    '--system'])
        grentry = grp.getgrnam(self.args.group)
        self.gid = grentry.gr_gid

        # Find xennigan user
        try:
            pwd.getpwnam(self.args.user)
        except KeyError:
            print("User {0} not found.  Create?".format(self.args.user))
            if not ask_confirmation():
                raise PleaseExit(-3)
            subprocess.check_call([
                    'adduser',
                    '--system', '--disabled-password',
                    '--shell', '/bin/bash',
                    '--ingroup', self.args.group,
                    '--home', '/var/lib/xennigan',
                    self.args.user])
        pwentry = pwd.getpwnam(self.args.user)
        self.uid = pwentry.pw_uid
        self.home = pwentry.pw_dir

        if (pwentry.pw_gid != grentry.gr_gid
                    and self.args.user not in grentry.gr_mem):
            print('User {0} not in group {1}.  Add?'.format(
                        self.args.user, self.args.group))
            if not ask_confirmation():
                raise PleaseExit(-5)
            subprocess.checkcall(['gpasswd', '-a', self.args.user,
                    self.args.group])

        # Check permissions on xennigan-shell binary
        st = os.stat(self.shell_path)
        if st.st_uid != 0:
            print("{0} isn't owned by superuser.  Fix?".format(
                    self.shell_path))
            if not ask_confirmation():
                raise PleaseExit(-7)
            os.chown(self.shell_path, 0, -1)
        if st.st_gid != self.gid:
            print("{0} isn't owned by group {1}.  Fix?".format(
                    self.shell_path, self.args.group))
            if not ask_confirmation():
                raise PleaseExit(-8)
            os.chown(self.shell_path, -1, self.gid)

        if st.st_mode != 0o104754:
            print("{0} has mode {1} instead of (10)4754.  Fix?".format(
                        self.shell_path, oct(st.st_mode)[2:]))
            if not ask_confirmation():
                raise PleaseExit(-9)
            os.chmod(self.shell_path, 0o4754)

        # Check for home dir
        if not os.path.isdir(self.home):
            print("Home dir {0} does not exist.".format(self.home))
            raise PleaseExit(-10)

        # Check for .ssh dir
        ssh_dir = os.path.join(self.home, '.ssh')
        if not os.path.exists(ssh_dir):
            print("Created {0}".format(ssh_dir))
            os.mkdir(ssh_dir)
            os.chown(ssh_dir, self.uid, self.gid)
            os.chmod(ssh_dir, 0o700)

        # Check for authorized_keys file
        self.ak_path = os.path.join(ssh_dir, 'authorized_keys')
        if not os.path.exists(self.ak_path):
            open(self.ak_path, 'w').close()
            os.chmod(self.ak_path, 0o600)
            os.chown(self.ak_path, self.uid, self.gid)

        # Check permission of authorized_keys file
        st = os.stat(self.ak_path)
        if not st.st_mode == 0o100600:
            print("Fixing mode of {0}".format(self.ak_path))
            os.chmod(self.ak_path, 0o600)
        if not st.st_uid == self.uid:
            print("Fixing owner of {0}".format(self.ak_path))
            os.chown(self.ak_path, self.uid, -1)
        if not st.st_gid == self.gid:
            print("Fixing group of {0}".format(self.ak_path))
            os.chown(self.ak_path, -1, self.gid)

        # Check domu configuration directory
        if not os.path.isdir(self.args.domu_cfg_dir):
            print("{0} does not exist".format(self.args.domu_cfg_dir))
            raise PleaseExit(-11)
        st = os.stat(self.args.domu_cfg_dir)
        if st.st_uid != 0:
            print("{0} is not owned by superuser")
            raise PleaseExit(-12)
        if st.st_mode & stat.S_IWGRP or st.st_mode & stat.S_IWOTH:
            print("{0} is not only writable by superuser")
            raise PleaseExit(-13)

        # Check if there are domus.
        ok = False
        for fn in os.listdir(self.args.domu_cfg_dir):
            if not fn.endswith('.cfg'):
                continue
            ok = True
            break
        if not ok:
            print("There aren't any domu configuration files in {0}".format(
                    self.args.domu_cfg_dir))
            raise PleaseExit(-14)


if __name__ == '__main__':
    try:
        code = Program().main(sys.argv[1:])
    except PleaseExit as e:
        code = e.code
    sys.exit(code)
